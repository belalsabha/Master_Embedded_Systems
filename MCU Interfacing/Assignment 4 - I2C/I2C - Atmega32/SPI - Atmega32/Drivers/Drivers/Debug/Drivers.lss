
Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003d8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  0000044c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00800060  00800060  0000044c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000044c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000047c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000100  00000000  00000000  000004b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e92  00000000  00000000  000005b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008d3  00000000  00000000  0000144a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000006e4  00000000  00000000  00001d1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000314  00000000  00000000  00002404  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005e1  00000000  00000000  00002718  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000697  00000000  00000000  00002cf9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c0  00000000  00000000  00003390  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 a6 00 	jmp	0x14c	; 0x14c <__vector_1>
   8:	0c 94 cd 00 	jmp	0x19a	; 0x19a <__vector_2>
   c:	0c 94 f4 00 	jmp	0x1e8	; 0x1e8 <__vector_3>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 9f 01 	jmp	0x33e	; 0x33e <__vector_19>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 ed       	ldi	r30, 0xD8	; 216
  68:	f3 e0       	ldi	r31, 0x03	; 3
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 36       	cpi	r26, 0x68	; 104
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 a1 00 	call	0x142	; 0x142 <main>
  8a:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Delay_ms>:
#define I2C_MODE_MASTER
//#define I2C_MODE_SLAVE

/* Simple delay */
void Delay_ms(uint16_t ms)
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	00 d0       	rcall	.+0      	; 0x98 <Delay_ms+0x6>
  98:	00 d0       	rcall	.+0      	; 0x9a <Delay_ms+0x8>
  9a:	cd b7       	in	r28, 0x3d	; 61
  9c:	de b7       	in	r29, 0x3e	; 62
    volatile uint16_t i, j;
    for(i=0; i<ms; i++)
  9e:	1a 82       	std	Y+2, r1	; 0x02
  a0:	19 82       	std	Y+1, r1	; 0x01
  a2:	14 c0       	rjmp	.+40     	; 0xcc <Delay_ms+0x3a>
        for(j=0; j<1000; j++);
  a4:	1c 82       	std	Y+4, r1	; 0x04
  a6:	1b 82       	std	Y+3, r1	; 0x03
  a8:	06 c0       	rjmp	.+12     	; 0xb6 <Delay_ms+0x24>
  aa:	2b 81       	ldd	r18, Y+3	; 0x03
  ac:	3c 81       	ldd	r19, Y+4	; 0x04
  ae:	2f 5f       	subi	r18, 0xFF	; 255
  b0:	3f 4f       	sbci	r19, 0xFF	; 255
  b2:	3c 83       	std	Y+4, r19	; 0x04
  b4:	2b 83       	std	Y+3, r18	; 0x03
  b6:	2b 81       	ldd	r18, Y+3	; 0x03
  b8:	3c 81       	ldd	r19, Y+4	; 0x04
  ba:	28 3e       	cpi	r18, 0xE8	; 232
  bc:	33 40       	sbci	r19, 0x03	; 3
  be:	a8 f3       	brcs	.-22     	; 0xaa <Delay_ms+0x18>

/* Simple delay */
void Delay_ms(uint16_t ms)
{
    volatile uint16_t i, j;
    for(i=0; i<ms; i++)
  c0:	29 81       	ldd	r18, Y+1	; 0x01
  c2:	3a 81       	ldd	r19, Y+2	; 0x02
  c4:	2f 5f       	subi	r18, 0xFF	; 255
  c6:	3f 4f       	sbci	r19, 0xFF	; 255
  c8:	3a 83       	std	Y+2, r19	; 0x02
  ca:	29 83       	std	Y+1, r18	; 0x01
  cc:	29 81       	ldd	r18, Y+1	; 0x01
  ce:	3a 81       	ldd	r19, Y+2	; 0x02
  d0:	28 17       	cp	r18, r24
  d2:	39 07       	cpc	r19, r25
  d4:	38 f3       	brcs	.-50     	; 0xa4 <Delay_ms+0x12>
        for(j=0; j<1000; j++);
}
  d6:	0f 90       	pop	r0
  d8:	0f 90       	pop	r0
  da:	0f 90       	pop	r0
  dc:	0f 90       	pop	r0
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	08 95       	ret

000000e4 <App_Init>:

/* ================= App Initialization ================= */
void App_Init(void)
{
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	cd b7       	in	r28, 0x3d	; 61
  ea:	de b7       	in	r29, 0x3e	; 62
  ec:	27 97       	sbiw	r28, 0x07	; 7
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	f8 94       	cli
  f2:	de bf       	out	0x3e, r29	; 62
  f4:	0f be       	out	0x3f, r0	; 63
  f6:	cd bf       	out	0x3d, r28	; 61
    I2C_Config_t I2C_Config;

#ifdef I2C_MODE_MASTER
    I2C_Config.Slave_Address = 0x00; // Master's target slave address
  f8:	19 82       	std	Y+1, r1	; 0x01
    I2C_Config.Speed = Speed_100;
  fa:	80 ea       	ldi	r24, 0xA0	; 160
  fc:	96 e8       	ldi	r25, 0x86	; 134
  fe:	9b 83       	std	Y+3, r25	; 0x03
 100:	8a 83       	std	Y+2, r24	; 0x02
    I2C_Config.Prescaler = Prescaler_1;
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	8c 83       	std	Y+4, r24	; 0x04
    I2C_Config.IRQ_Enable = I2C_IRQ_Disable;
 106:	1d 82       	std	Y+5, r1	; 0x05
    I2C_Config.Ptr_ISR_Func = 0;
 108:	1f 82       	std	Y+7, r1	; 0x07
 10a:	1e 82       	std	Y+6, r1	; 0x06

    IOA->DDR = 0xFF; // Port A as output for LEDs or display
 10c:	8f ef       	ldi	r24, 0xFF	; 255
 10e:	8a bb       	out	0x1a, r24	; 26
    I2C_Config.Ptr_ISR_Func = 0;

    IOA->DDR = 0xFF; // optional: output to show received data
#endif

    MCAL_I2C_Init(I2C, &I2C_Config);
 110:	be 01       	movw	r22, r28
 112:	6f 5f       	subi	r22, 0xFF	; 255
 114:	7f 4f       	sbci	r23, 0xFF	; 255
 116:	80 e2       	ldi	r24, 0x20	; 32
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	0e 94 1b 01 	call	0x236	; 0x236 <MCAL_I2C_Init>
}
 11e:	27 96       	adiw	r28, 0x07	; 7
 120:	0f b6       	in	r0, 0x3f	; 63
 122:	f8 94       	cli
 124:	de bf       	out	0x3e, r29	; 62
 126:	0f be       	out	0x3f, r0	; 63
 128:	cd bf       	out	0x3d, r28	; 61
 12a:	df 91       	pop	r29
 12c:	cf 91       	pop	r28
 12e:	08 95       	ret

00000130 <App_Run>:

/* ================= App Main Loop ================= */
void App_Run(void)
{
#ifdef I2C_MODE_MASTER
    uint8_t Received_data = MCAL_I2C_Master_Recieve(0xD0);
 130:	80 ed       	ldi	r24, 0xD0	; 208
 132:	0e 94 85 01 	call	0x30a	; 0x30a <MCAL_I2C_Master_Recieve>
    IOA->PORT = Received_data; // display received byte
 136:	8b bb       	out	0x1b, r24	; 27
    Delay_ms(500);
 138:	84 ef       	ldi	r24, 0xF4	; 244
 13a:	91 e0       	ldi	r25, 0x01	; 1
 13c:	0e 94 49 00 	call	0x92	; 0x92 <Delay_ms>
 140:	08 95       	ret

00000142 <main>:
/* For  Atmega32 Simulation */ 
int main(void) {
	


 App_Init();
 142:	0e 94 72 00 	call	0xe4	; 0xe4 <App_Init>


	while (1) {
			

		 App_Run();
 146:	0e 94 98 00 	call	0x130	; 0x130 <App_Run>
 14a:	fd cf       	rjmp	.-6      	; 0x146 <main+0x4>

0000014c <__vector_1>:


// ISRs
// ISRs
void __vector_1(void) __attribute__((signal, used)); // INT0
void __vector_1(void) {
 14c:	1f 92       	push	r1
 14e:	0f 92       	push	r0
 150:	0f b6       	in	r0, 0x3f	; 63
 152:	0f 92       	push	r0
 154:	11 24       	eor	r1, r1
 156:	2f 93       	push	r18
 158:	3f 93       	push	r19
 15a:	4f 93       	push	r20
 15c:	5f 93       	push	r21
 15e:	6f 93       	push	r22
 160:	7f 93       	push	r23
 162:	8f 93       	push	r24
 164:	9f 93       	push	r25
 166:	af 93       	push	r26
 168:	bf 93       	push	r27
 16a:	ef 93       	push	r30
 16c:	ff 93       	push	r31
	
	 /*if (GP_IRQ_FUNC_CALLBACK[0])*/
	  GP_IRQ_FUNC_CALLBACK[0](); 
 16e:	e0 91 62 00 	lds	r30, 0x0062	; 0x800062 <GP_IRQ_FUNC_CALLBACK>
 172:	f0 91 63 00 	lds	r31, 0x0063	; 0x800063 <GP_IRQ_FUNC_CALLBACK+0x1>
 176:	09 95       	icall
	 }
 178:	ff 91       	pop	r31
 17a:	ef 91       	pop	r30
 17c:	bf 91       	pop	r27
 17e:	af 91       	pop	r26
 180:	9f 91       	pop	r25
 182:	8f 91       	pop	r24
 184:	7f 91       	pop	r23
 186:	6f 91       	pop	r22
 188:	5f 91       	pop	r21
 18a:	4f 91       	pop	r20
 18c:	3f 91       	pop	r19
 18e:	2f 91       	pop	r18
 190:	0f 90       	pop	r0
 192:	0f be       	out	0x3f, r0	; 63
 194:	0f 90       	pop	r0
 196:	1f 90       	pop	r1
 198:	18 95       	reti

0000019a <__vector_2>:

void __vector_2(void) __attribute__((signal, used)); // INT1
void __vector_2(void) { 
 19a:	1f 92       	push	r1
 19c:	0f 92       	push	r0
 19e:	0f b6       	in	r0, 0x3f	; 63
 1a0:	0f 92       	push	r0
 1a2:	11 24       	eor	r1, r1
 1a4:	2f 93       	push	r18
 1a6:	3f 93       	push	r19
 1a8:	4f 93       	push	r20
 1aa:	5f 93       	push	r21
 1ac:	6f 93       	push	r22
 1ae:	7f 93       	push	r23
 1b0:	8f 93       	push	r24
 1b2:	9f 93       	push	r25
 1b4:	af 93       	push	r26
 1b6:	bf 93       	push	r27
 1b8:	ef 93       	push	r30
 1ba:	ff 93       	push	r31
	/*if (GP_IRQ_FUNC_CALLBACK[1])*/
	 GP_IRQ_FUNC_CALLBACK[1](); 
 1bc:	e0 91 64 00 	lds	r30, 0x0064	; 0x800064 <GP_IRQ_FUNC_CALLBACK+0x2>
 1c0:	f0 91 65 00 	lds	r31, 0x0065	; 0x800065 <GP_IRQ_FUNC_CALLBACK+0x3>
 1c4:	09 95       	icall
	}
 1c6:	ff 91       	pop	r31
 1c8:	ef 91       	pop	r30
 1ca:	bf 91       	pop	r27
 1cc:	af 91       	pop	r26
 1ce:	9f 91       	pop	r25
 1d0:	8f 91       	pop	r24
 1d2:	7f 91       	pop	r23
 1d4:	6f 91       	pop	r22
 1d6:	5f 91       	pop	r21
 1d8:	4f 91       	pop	r20
 1da:	3f 91       	pop	r19
 1dc:	2f 91       	pop	r18
 1de:	0f 90       	pop	r0
 1e0:	0f be       	out	0x3f, r0	; 63
 1e2:	0f 90       	pop	r0
 1e4:	1f 90       	pop	r1
 1e6:	18 95       	reti

000001e8 <__vector_3>:

void __vector_3(void) __attribute__((signal, used)); // INT2
void __vector_3(void) { 
 1e8:	1f 92       	push	r1
 1ea:	0f 92       	push	r0
 1ec:	0f b6       	in	r0, 0x3f	; 63
 1ee:	0f 92       	push	r0
 1f0:	11 24       	eor	r1, r1
 1f2:	2f 93       	push	r18
 1f4:	3f 93       	push	r19
 1f6:	4f 93       	push	r20
 1f8:	5f 93       	push	r21
 1fa:	6f 93       	push	r22
 1fc:	7f 93       	push	r23
 1fe:	8f 93       	push	r24
 200:	9f 93       	push	r25
 202:	af 93       	push	r26
 204:	bf 93       	push	r27
 206:	ef 93       	push	r30
 208:	ff 93       	push	r31
	/*if (GP_IRQ_FUNC_CALLBACK[2])*/
	 GP_IRQ_FUNC_CALLBACK[2](); 
 20a:	e0 91 66 00 	lds	r30, 0x0066	; 0x800066 <GP_IRQ_FUNC_CALLBACK+0x4>
 20e:	f0 91 67 00 	lds	r31, 0x0067	; 0x800067 <GP_IRQ_FUNC_CALLBACK+0x5>
 212:	09 95       	icall
 214:	ff 91       	pop	r31
 216:	ef 91       	pop	r30
 218:	bf 91       	pop	r27
 21a:	af 91       	pop	r26
 21c:	9f 91       	pop	r25
 21e:	8f 91       	pop	r24
 220:	7f 91       	pop	r23
 222:	6f 91       	pop	r22
 224:	5f 91       	pop	r21
 226:	4f 91       	pop	r20
 228:	3f 91       	pop	r19
 22a:	2f 91       	pop	r18
 22c:	0f 90       	pop	r0
 22e:	0f be       	out	0x3f, r0	; 63
 230:	0f 90       	pop	r0
 232:	1f 90       	pop	r1
 234:	18 95       	reti

00000236 <MCAL_I2C_Init>:
uint8_t MCAL_I2C_Slave_Recieve(void)
{
	TWCR = (1<<7)|(1<<2)|(1<<6);
	while(!(TWCR & (1<<7)));
	return I2C->TWDR;
}
 236:	0f 93       	push	r16
 238:	1f 93       	push	r17
 23a:	cf 93       	push	r28
 23c:	df 93       	push	r29
 23e:	8c 01       	movw	r16, r24
 240:	eb 01       	movw	r28, r22
 242:	88 81       	ld	r24, Y
 244:	88 0f       	add	r24, r24
 246:	f8 01       	movw	r30, r16
 248:	82 83       	std	Z+2, r24	; 0x02
 24a:	8b 81       	ldd	r24, Y+3	; 0x03
 24c:	84 30       	cpi	r24, 0x04	; 4
 24e:	71 f0       	breq	.+28     	; 0x26c <MCAL_I2C_Init+0x36>
 250:	18 f4       	brcc	.+6      	; 0x258 <MCAL_I2C_Init+0x22>
 252:	81 30       	cpi	r24, 0x01	; 1
 254:	31 f0       	breq	.+12     	; 0x262 <MCAL_I2C_Init+0x2c>
 256:	1a c0       	rjmp	.+52     	; 0x28c <MCAL_I2C_Init+0x56>
 258:	80 31       	cpi	r24, 0x10	; 16
 25a:	71 f0       	breq	.+28     	; 0x278 <MCAL_I2C_Init+0x42>
 25c:	80 34       	cpi	r24, 0x40	; 64
 25e:	91 f0       	breq	.+36     	; 0x284 <MCAL_I2C_Init+0x4e>
 260:	15 c0       	rjmp	.+42     	; 0x28c <MCAL_I2C_Init+0x56>
 262:	f8 01       	movw	r30, r16
 264:	81 81       	ldd	r24, Z+1	; 0x01
 266:	8c 7f       	andi	r24, 0xFC	; 252
 268:	81 83       	std	Z+1, r24	; 0x01
 26a:	10 c0       	rjmp	.+32     	; 0x28c <MCAL_I2C_Init+0x56>
 26c:	f8 01       	movw	r30, r16
 26e:	81 81       	ldd	r24, Z+1	; 0x01
 270:	8c 7f       	andi	r24, 0xFC	; 252
 272:	81 60       	ori	r24, 0x01	; 1
 274:	81 83       	std	Z+1, r24	; 0x01
 276:	0a c0       	rjmp	.+20     	; 0x28c <MCAL_I2C_Init+0x56>
 278:	f8 01       	movw	r30, r16
 27a:	81 81       	ldd	r24, Z+1	; 0x01
 27c:	8c 7f       	andi	r24, 0xFC	; 252
 27e:	82 60       	ori	r24, 0x02	; 2
 280:	81 83       	std	Z+1, r24	; 0x01
 282:	04 c0       	rjmp	.+8      	; 0x28c <MCAL_I2C_Init+0x56>
 284:	f8 01       	movw	r30, r16
 286:	81 81       	ldd	r24, Z+1	; 0x01
 288:	83 60       	ori	r24, 0x03	; 3
 28a:	81 83       	std	Z+1, r24	; 0x01
 28c:	29 81       	ldd	r18, Y+1	; 0x01
 28e:	3a 81       	ldd	r19, Y+2	; 0x02
 290:	40 e0       	ldi	r20, 0x00	; 0
 292:	50 e0       	ldi	r21, 0x00	; 0
 294:	60 e0       	ldi	r22, 0x00	; 0
 296:	72 e1       	ldi	r23, 0x12	; 18
 298:	8a e7       	ldi	r24, 0x7A	; 122
 29a:	90 e0       	ldi	r25, 0x00	; 0
 29c:	0e 94 c8 01 	call	0x390	; 0x390 <__udivmodsi4>
 2a0:	ca 01       	movw	r24, r20
 2a2:	b9 01       	movw	r22, r18
 2a4:	60 51       	subi	r22, 0x10	; 16
 2a6:	71 09       	sbc	r23, r1
 2a8:	81 09       	sbc	r24, r1
 2aa:	91 09       	sbc	r25, r1
 2ac:	2b 81       	ldd	r18, Y+3	; 0x03
 2ae:	30 e0       	ldi	r19, 0x00	; 0
 2b0:	22 0f       	add	r18, r18
 2b2:	33 1f       	adc	r19, r19
 2b4:	03 2e       	mov	r0, r19
 2b6:	00 0c       	add	r0, r0
 2b8:	44 0b       	sbc	r20, r20
 2ba:	55 0b       	sbc	r21, r21
 2bc:	0e 94 c8 01 	call	0x390	; 0x390 <__udivmodsi4>
 2c0:	f8 01       	movw	r30, r16
 2c2:	20 83       	st	Z, r18
 2c4:	84 e4       	ldi	r24, 0x44	; 68
 2c6:	86 bf       	out	0x36, r24	; 54
 2c8:	8c 81       	ldd	r24, Y+4	; 0x04
 2ca:	81 30       	cpi	r24, 0x01	; 1
 2cc:	61 f4       	brne	.+24     	; 0x2e6 <MCAL_I2C_Init+0xb0>
 2ce:	86 b7       	in	r24, 0x36	; 54
 2d0:	81 60       	ori	r24, 0x01	; 1
 2d2:	86 bf       	out	0x36, r24	; 54
 2d4:	8d 81       	ldd	r24, Y+5	; 0x05
 2d6:	9e 81       	ldd	r25, Y+6	; 0x06
 2d8:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 2dc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 2e0:	8f b7       	in	r24, 0x3f	; 63
 2e2:	80 68       	ori	r24, 0x80	; 128
 2e4:	8f bf       	out	0x3f, r24	; 63
 2e6:	df 91       	pop	r29
 2e8:	cf 91       	pop	r28
 2ea:	1f 91       	pop	r17
 2ec:	0f 91       	pop	r16
 2ee:	08 95       	ret

000002f0 <Generate_Start_Bit>:
 2f0:	84 ea       	ldi	r24, 0xA4	; 164
 2f2:	86 bf       	out	0x36, r24	; 54
 2f4:	06 b6       	in	r0, 0x36	; 54
 2f6:	07 fe       	sbrs	r0, 7
 2f8:	fd cf       	rjmp	.-6      	; 0x2f4 <Generate_Start_Bit+0x4>
 2fa:	81 b1       	in	r24, 0x01	; 1
 2fc:	88 7f       	andi	r24, 0xF8	; 248
 2fe:	88 30       	cpi	r24, 0x08	; 8
 300:	e1 f7       	brne	.-8      	; 0x2fa <Generate_Start_Bit+0xa>
 302:	08 95       	ret

00000304 <Generate_Stop_Bit>:
 304:	84 e9       	ldi	r24, 0x94	; 148
 306:	86 bf       	out	0x36, r24	; 54
 308:	08 95       	ret

0000030a <MCAL_I2C_Master_Recieve>:
 30a:	cf 93       	push	r28
 30c:	c8 2f       	mov	r28, r24
 30e:	0e 94 78 01 	call	0x2f0	; 0x2f0 <Generate_Start_Bit>
 312:	8c 2f       	mov	r24, r28
 314:	90 e0       	ldi	r25, 0x00	; 0
 316:	88 0f       	add	r24, r24
 318:	99 1f       	adc	r25, r25
 31a:	81 60       	ori	r24, 0x01	; 1
 31c:	83 b9       	out	0x03, r24	; 3
 31e:	84 e8       	ldi	r24, 0x84	; 132
 320:	86 bf       	out	0x36, r24	; 54
 322:	06 b6       	in	r0, 0x36	; 54
 324:	07 fe       	sbrs	r0, 7
 326:	fd cf       	rjmp	.-6      	; 0x322 <MCAL_I2C_Master_Recieve+0x18>
 328:	84 e8       	ldi	r24, 0x84	; 132
 32a:	86 bf       	out	0x36, r24	; 54
 32c:	06 b6       	in	r0, 0x36	; 54
 32e:	07 fe       	sbrs	r0, 7
 330:	fd cf       	rjmp	.-6      	; 0x32c <MCAL_I2C_Master_Recieve+0x22>
 332:	c3 b1       	in	r28, 0x03	; 3
 334:	0e 94 82 01 	call	0x304	; 0x304 <Generate_Stop_Bit>
 338:	8c 2f       	mov	r24, r28
 33a:	cf 91       	pop	r28
 33c:	08 95       	ret

0000033e <__vector_19>:

void __vector_19(void) __attribute__((signal, used));
void __vector_19(void)
{
 33e:	1f 92       	push	r1
 340:	0f 92       	push	r0
 342:	0f b6       	in	r0, 0x3f	; 63
 344:	0f 92       	push	r0
 346:	11 24       	eor	r1, r1
 348:	2f 93       	push	r18
 34a:	3f 93       	push	r19
 34c:	4f 93       	push	r20
 34e:	5f 93       	push	r21
 350:	6f 93       	push	r22
 352:	7f 93       	push	r23
 354:	8f 93       	push	r24
 356:	9f 93       	push	r25
 358:	af 93       	push	r26
 35a:	bf 93       	push	r27
 35c:	ef 93       	push	r30
 35e:	ff 93       	push	r31
	if(I2C_Callback) I2C_Callback();
 360:	e0 91 60 00 	lds	r30, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 364:	f0 91 61 00 	lds	r31, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 368:	30 97       	sbiw	r30, 0x00	; 0
 36a:	09 f0       	breq	.+2      	; 0x36e <__vector_19+0x30>
 36c:	09 95       	icall
}
 36e:	ff 91       	pop	r31
 370:	ef 91       	pop	r30
 372:	bf 91       	pop	r27
 374:	af 91       	pop	r26
 376:	9f 91       	pop	r25
 378:	8f 91       	pop	r24
 37a:	7f 91       	pop	r23
 37c:	6f 91       	pop	r22
 37e:	5f 91       	pop	r21
 380:	4f 91       	pop	r20
 382:	3f 91       	pop	r19
 384:	2f 91       	pop	r18
 386:	0f 90       	pop	r0
 388:	0f be       	out	0x3f, r0	; 63
 38a:	0f 90       	pop	r0
 38c:	1f 90       	pop	r1
 38e:	18 95       	reti

00000390 <__udivmodsi4>:
 390:	a1 e2       	ldi	r26, 0x21	; 33
 392:	1a 2e       	mov	r1, r26
 394:	aa 1b       	sub	r26, r26
 396:	bb 1b       	sub	r27, r27
 398:	fd 01       	movw	r30, r26
 39a:	0d c0       	rjmp	.+26     	; 0x3b6 <__udivmodsi4_ep>

0000039c <__udivmodsi4_loop>:
 39c:	aa 1f       	adc	r26, r26
 39e:	bb 1f       	adc	r27, r27
 3a0:	ee 1f       	adc	r30, r30
 3a2:	ff 1f       	adc	r31, r31
 3a4:	a2 17       	cp	r26, r18
 3a6:	b3 07       	cpc	r27, r19
 3a8:	e4 07       	cpc	r30, r20
 3aa:	f5 07       	cpc	r31, r21
 3ac:	20 f0       	brcs	.+8      	; 0x3b6 <__udivmodsi4_ep>
 3ae:	a2 1b       	sub	r26, r18
 3b0:	b3 0b       	sbc	r27, r19
 3b2:	e4 0b       	sbc	r30, r20
 3b4:	f5 0b       	sbc	r31, r21

000003b6 <__udivmodsi4_ep>:
 3b6:	66 1f       	adc	r22, r22
 3b8:	77 1f       	adc	r23, r23
 3ba:	88 1f       	adc	r24, r24
 3bc:	99 1f       	adc	r25, r25
 3be:	1a 94       	dec	r1
 3c0:	69 f7       	brne	.-38     	; 0x39c <__udivmodsi4_loop>
 3c2:	60 95       	com	r22
 3c4:	70 95       	com	r23
 3c6:	80 95       	com	r24
 3c8:	90 95       	com	r25
 3ca:	9b 01       	movw	r18, r22
 3cc:	ac 01       	movw	r20, r24
 3ce:	bd 01       	movw	r22, r26
 3d0:	cf 01       	movw	r24, r30
 3d2:	08 95       	ret

000003d4 <_exit>:
 3d4:	f8 94       	cli

000003d6 <__stop_program>:
 3d6:	ff cf       	rjmp	.-2      	; 0x3d6 <__stop_program>
